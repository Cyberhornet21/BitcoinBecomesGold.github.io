<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Bitcoin Seasons</title>
<link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;1,400&display=swap" rel="stylesheet"/>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
html,body { width:100%; height:100%; overflow:hidden; background:#000; cursor:none; }
canvas { display:block; position:fixed; top:0; left:0; }

#cursor {
  position:fixed; width:6px; height:6px; border-radius:50%;
  background:rgba(255,255,255,0.9); transform:translate(-50%,-50%);
  pointer-events:none; z-index:100; mix-blend-mode:difference;
}
#cursor-ring {
  position:fixed; width:28px; height:28px; border-radius:50%;
  border:1px solid rgba(255,255,255,0.25); transform:translate(-50%,-50%);
  pointer-events:none; z-index:99; transition:border-color 1s;
}

#loader {
  position:fixed; inset:0; background:#050a14;
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  gap:1.2rem; z-index:200; transition:opacity 2s ease;
}
#loader.fade { opacity:0; pointer-events:none; }
.loader-title {
  font-family:'EB Garamond',serif; font-size:1.1rem; letter-spacing:0.5em;
  color:rgba(255,255,255,0.15); text-transform:uppercase;
  animation:lp 2.5s ease-in-out infinite;
}
.loader-sub {
  font-family:'EB Garamond',serif; font-size:0.55rem; letter-spacing:0.4em;
  color:rgba(255,255,255,0.07); text-transform:uppercase;
}
@keyframes lp { 0%,100%{opacity:0.15} 50%{opacity:0.6} }

#footer {
  position:fixed; bottom:0; left:0; right:0; height:68px;
  display:flex; align-items:center; justify-content:center;
  pointer-events:all; opacity:0; transition:opacity 2s ease;
  z-index:20; gap:0;
}
#footer.visible { opacity:1; }
.fi { display:flex; flex-direction:column; align-items:center; gap:4px; padding:0 4vw; position:relative; }
.fi+.fi::before {
  content:''; position:absolute; left:0; top:22%; height:56%;
  width:1px; background:rgba(255,255,255,0.07);
}
.fl {
  font-family:'EB Garamond',serif; font-size:0.45rem; letter-spacing:0.4em;
  text-transform:uppercase; color:rgba(255,255,255,0.2); user-select:none;
  transition:color 0.4s;
}
.fi:hover .fl { color:rgba(255,255,255,0.45); }
.fv {
  font-family:'EB Garamond',serif; font-size:clamp(0.85rem,1.8vw,1.15rem);
  letter-spacing:0.06em; color:rgba(255,255,255,0.5);
  border:none; background:transparent; outline:none; text-align:center;
  width:14ch; cursor:pointer; caret-color:rgba(255,255,255,0.7);
  border-bottom:1px solid transparent; transition:color 0.4s, border-bottom 0.3s;
}
.fv:hover { color:rgba(255,255,255,0.8); border-bottom:1px solid rgba(255,255,255,0.12); }
.fv:focus { color:#fff; border-bottom:1px solid rgba(255,255,255,0.35); cursor:text; }
.fi.cur .fv { color:rgba(255,255,255,0.7); font-size:clamp(0.95rem,2vw,1.2rem); font-style:italic; }
@keyframes vflash { 0%{color:rgba(200,230,255,1)} 100%{color:rgba(255,255,255,0.5)} }
.fv.flash { animation:vflash 1s ease forwards; }

#hint {
  position:fixed; bottom:74px; left:50%; transform:translateX(-50%);
  font-family:'EB Garamond',serif; font-style:italic; font-size:0.55rem;
  letter-spacing:0.3em; color:rgba(255,255,255,0);
  text-transform:lowercase; white-space:nowrap; transition:color 3s ease;
  pointer-events:none; z-index:15;
}
#hint.visible { color:rgba(255,255,255,0.13); }
</style>
</head>
<body>

<div id="loader">
  <div class="loader-title">Bitcoin Seasons</div>
  <div class="loader-sub">Reading the market</div>
</div>

<div id="cursor"></div>
<div id="cursor-ring"></div>
<canvas id="c"></canvas>

<div id="hint">move · scroll · click</div>

<div id="footer">
  <div class="fi low">
    <span class="fl">Day Low</span>
    <input class="fv" id="f-low" type="text" inputmode="numeric" value="—"/>
  </div>
  <div class="fi cur">
    <span class="fl">Current</span>
    <input class="fv" id="f-price" type="text" inputmode="numeric" value="—"/>
  </div>
  <div class="fi high">
    <span class="fl">Day High</span>
    <input class="fv" id="f-high" type="text" inputmode="numeric" value="—"/>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════
//  STATE
// ═══════════════════════════════════════════════════════════
const S = {
  price:0, high:0, low:0,
  pos:0.5, vol:0.5,
  targetPos:0.5, smoothPos:0.5,
  mouse:{x:0.5,y:0.5}, tmouse:{x:0.5,y:0.5},
  scroll:0, pulses:[], time:0,
  loaded:false, priceStr:'',
  windOffset:0, windSpeed:0,
};

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;
function resize(){ W=canvas.width=window.innerWidth; H=canvas.height=window.innerHeight; }
resize(); window.addEventListener('resize',resize);

// ═══════════════════════════════════════════════════════════
//  HELPERS
// ═══════════════════════════════════════════════════════════
const lerp = (a,b,t)=>a+(b-a)*t;
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
function lc(t,a,b){ return [lerp(a[0],b[0],t)|0, lerp(a[1],b[1],t)|0, lerp(a[2],b[2],t)|0]; }
function rgb([r,g,b],a=1){ return a<1?`rgba(${r},${g},${b},${a})`:`rgb(${r},${g},${b})`; }
// smooth ease in-out
function ease(t){ return t<0.5?2*t*t:1-2*(1-t)*(1-t); }
// simplex-like noise
function sn(x,t){ return Math.sin(x*2.3+t*0.7)*0.5+Math.sin(x*5.1-t*0.4)*0.3+Math.sin(x*11+t*1.1)*0.2; }

function fmt(n){
  return new Intl.NumberFormat('en-US',{style:'currency',currency:'USD',
    minimumFractionDigits:0,maximumFractionDigits:0}).format(n);
}
function parseVal(s){ return parseFloat(String(s).replace(/[^0-9.]/g,'')); }

function recalc(){
  const range = S.high - S.low || 1;
  S.pos = clamp((S.price-S.low)/range,0,1);
  S.vol = clamp(range/S.price*15,0,1);
  S.targetPos = S.pos;
  S.priceStr = fmt(S.price);
}

// ═══════════════════════════════════════════════════════════
//  FOOTER
// ═══════════════════════════════════════════════════════════
const fLow=document.getElementById('f-low');
const fPr=document.getElementById('f-price');
const fHigh=document.getElementById('f-high');
const footer=document.getElementById('footer');

function updFooter(){ fLow.value=fmt(S.low); fHigh.value=fmt(S.high); fPr.value=fmt(S.price); }
function flashEl(el){ el.classList.remove('flash'); void el.offsetWidth; el.classList.add('flash'); }

function bindInput(el,key){
  el.addEventListener('focus',()=>{ el.value=Math.round(S[key]); el.select(); });
  el.addEventListener('blur',()=>{
    const v=parseVal(el.value);
    if(!isNaN(v)&&v>0){ S[key]=v; recalc(); flashEl(el); }
    updFooter();
  });
  el.addEventListener('keydown',e=>{
    if(e.key==='Enter') el.blur();
    if(e.key==='Escape'){ updFooter(); el.blur(); }
  });
  el.addEventListener('click',e=>e.stopPropagation());
  el.addEventListener('mousedown',e=>e.stopPropagation());
}
bindInput(fLow,'low'); bindInput(fPr,'price'); bindInput(fHigh,'high');

// ═══════════════════════════════════════════════════════════
//  API
// ═══════════════════════════════════════════════════════════
async function fetchData(){
  try{
    const r=await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=bitcoin');
    const d=await r.json(); const b=d[0];
    S.price=b.current_price; S.high=b.high_24h; S.low=b.low_24h;
    recalc(); updFooter();
    if(!S.loaded){
      S.loaded=true; S.smoothPos=S.pos;
      document.getElementById('loader').classList.add('fade');
      setTimeout(()=>{
        const l=document.getElementById('loader'); if(l)l.remove();
        footer.classList.add('visible');
        setTimeout(()=>document.getElementById('hint').classList.add('visible'),2500);
      },1800);
    }
  }catch(e){}
}
fetchData(); setInterval(fetchData,30000);

// ═══════════════════════════════════════════════════════════
//  INPUT
// ═══════════════════════════════════════════════════════════
const cursor=document.getElementById('cursor');
const ring=document.getElementById('cursor-ring');
window.addEventListener('mousemove',e=>{
  cursor.style.left=e.clientX+'px'; cursor.style.top=e.clientY+'px';
  ring.style.left=e.clientX+'px'; ring.style.top=e.clientY+'px';
  S.tmouse.x=e.clientX/W; S.tmouse.y=e.clientY/H;
});
window.addEventListener('wheel',e=>{
  S.scroll+=e.deltaY*0.0004; S.scroll=clamp(S.scroll,-0.35,0.35);
});
window.addEventListener('click',e=>{
  S.pulses.push({x:e.clientX/W,y:e.clientY/H,r:0,life:1});
});
setInterval(()=>{ S.scroll=lerp(S.scroll,0,0.04); },50);

// ═══════════════════════════════════════════════════════════
//  PARTICLES
// ═══════════════════════════════════════════════════════════
// Snow + petals + fireflies all share same pool, type switches with season
const NPART = 220;
const particles = Array.from({length:NPART},(_,i)=>({
  x:Math.random(), y:Math.random(),
  vx:0, vy:Math.random()*0.0008+0.0002,
  r:Math.random()*3+0.5,
  phase:Math.random()*Math.PI*2,
  wobble:Math.random()*0.003+0.001,
  opacity:Math.random()*0.6+0.3,
  type:0, // 0=snow 1=petal 2=dust 3=firefly
  glow:0,
}));

// Trees/vegetation — fixed horizontal positions
const TREES = Array.from({length:14},(_,i)=>({
  xn: (i+0.5)/14 + (Math.random()-0.5)*0.04,
  size: 0.4+Math.random()*0.6,
  phase: Math.random()*Math.PI*2,
}));

// Icicles
const ICICLES = Array.from({length:22},(_,i)=>({
  xn:(i+0.3+Math.random()*0.4)/22,
  len:0.03+Math.random()*0.06,
  w:2+Math.random()*3,
}));

// ═══════════════════════════════════════════════════════════
//  SEASON PALETTE
//  p=0 → deep winter (ice blue, grey)
//  p=0.5 → spring/autumn (green, mild)
//  p=1 → high summer (golden, vibrant)
// ═══════════════════════════════════════════════════════════
function seasonPalette(p){
  // Sky
  const skyTop  = p<0.5
    ? lc(p*2, [8,14,28],[95,130,90])
    : lc((p-0.5)*2, [95,130,90],[220,180,80]);
  const skyMid  = p<0.5
    ? lc(p*2, [20,32,65],[140,185,130])
    : lc((p-0.5)*2, [140,185,130],[255,210,100]);
  const skyHor  = p<0.5
    ? lc(p*2, [60,80,120],[160,200,150])
    : lc((p-0.5)*2, [160,200,150],[255,160,60]);

  // Ground
  const gndTop  = p<0.25
    ? lc(p*4, [200,215,235],[230,235,240])   // ice to snow
    : p<0.5
    ? lc((p-0.25)*4, [230,235,240],[80,110,60])  // snow melting to green
    : p<0.75
    ? lc((p-0.5)*4, [80,110,60],[100,140,60])
    : lc((p-0.75)*4, [100,140,60],[190,170,80]); // dry summer
  const gndBot  = p<0.5
    ? lc(p*2, [140,160,190],[50,70,40])
    : lc((p-0.5)*2, [50,70,40],[130,110,50]);

  // Sun color
  const sunCol  = p<0.5
    ? lc(p*2, [140,170,220],[230,240,220])
    : lc((p-0.5)*2, [230,240,220],[255,230,120]);

  // Sun size factor
  const sunSize = lerp(0.7, 1.6, p);

  // Fog/breath
  const fog = p<0.5
    ? lc(p*2, [160,180,220],[200,220,200])
    : lc((p-0.5)*2, [200,220,200],[255,220,150]);

  // Ice/snow tint
  const iceCol = [195,215,240];

  return { skyTop,skyMid,skyHor,gndTop,gndBot,sunCol,sunSize,fog,iceCol };
}

// ═══════════════════════════════════════════════════════════
//  DRAW LOOP
// ═══════════════════════════════════════════════════════════
function draw(){
  S.time += 0.007;

  S.smoothPos = lerp(S.smoothPos, clamp(S.targetPos+S.scroll,0,1), 0.012);
  S.mouse.x = lerp(S.mouse.x,S.tmouse.x,0.05);
  S.mouse.y = lerp(S.mouse.y,S.tmouse.y,0.05);

  // Wind
  const windTarget = S.vol * 0.018 * (0.5+0.5*Math.sin(S.time*0.3));
  S.windSpeed = lerp(S.windSpeed, windTarget, 0.02);
  S.windOffset += S.windSpeed;

  if(!S.loaded){ requestAnimationFrame(draw); return; }

  const p   = S.smoothPos;
  const vol = S.vol;
  const C   = seasonPalette(p);
  const mx  = S.mouse.x;
  const my  = S.mouse.y;

  ctx.clearRect(0,0,W,H);

  const horizonY = H * 0.44;

  drawSky(p, vol, C, mx, my, horizonY);
  drawMountains(p, vol, C, horizonY);
  drawGround(p, vol, C, horizonY);
  if(p < 0.3) drawIcicles(p, C, horizonY);
  drawVegetation(p, vol, C, mx, horizonY);
  drawParticles(p, vol, C);
  if(p > 0.6) drawFireflies(p, vol);
  drawPriceInLandscape(p, C, horizonY);
  drawPulses(p, C, vol);
  drawWindLines(vol, p);
  drawVignette(p);

  requestAnimationFrame(draw);
}

// ── SKY ──────────────────────────────────────────────────────────────────────
function drawSky(p, vol, C, mx, my, horizonY){
  const sg = ctx.createLinearGradient(0,0,0,horizonY);
  sg.addColorStop(0, rgb(C.skyTop));
  sg.addColorStop(0.55, rgb(C.skyMid));
  sg.addColorStop(1, rgb(C.skyHor));
  ctx.fillStyle = sg;
  ctx.fillRect(0,0,W,horizonY+2);

  // Aurora in winter (p<0.25)
  if(p < 0.28){
    const aI = (0.28-p)/0.28;
    for(let i=0;i<4;i++){
      const ay = H*0.08 + i*H*0.06 + Math.sin(S.time*0.4+i*1.3)*H*0.04;
      const ag = ctx.createLinearGradient(0,ay,0,ay+H*0.12);
      const hue = 150+i*25+Math.sin(S.time*0.2+i)*20;
      ag.addColorStop(0,`hsla(${hue},80%,55%,0)`);
      ag.addColorStop(0.4,`hsla(${hue},80%,55%,${aI*0.15})`);
      ag.addColorStop(1,`hsla(${hue},80%,55%,0)`);
      ctx.fillStyle=ag;
      for(let x=0;x<W;x+=4){
        const nx=x/W;
        const wave = Math.sin(nx*6+S.time*0.5+i*2)*H*0.04*aI;
        ctx.fillRect(x, ay+wave, 4, H*0.12);
      }
    }
  }

  // Stars in winter
  if(p < 0.4){
    const si = (0.4-p)/0.4;
    ctx.save();
    for(let i=0;i<60;i++){
      const sx = ((i*137.5)%1)*W;
      const sy = ((i*91.3)%1)*horizonY*0.85;
      const sr = 0.4+((i*53)%10)/10*0.8;
      const sa = si*(0.3+((i*71)%100)/100*0.5)*Math.abs(Math.sin(S.time*0.3+i));
      ctx.beginPath(); ctx.arc(sx,sy,sr,0,Math.PI*2);
      ctx.fillStyle=`rgba(220,230,255,${sa})`; ctx.fill();
    }
    ctx.restore();
  }

  // Sun
  const sunX = W*(0.62+(mx-0.5)*0.05);
  const sunY = lerp(horizonY*1.1, horizonY*0.18, p);
  const sunR = lerp(24, 52, p)*C.sunSize;

  // Haze/corona
  if(p > 0.5){
    const corona = ctx.createRadialGradient(sunX,sunY,sunR*0.6,sunX,sunY,sunR*4);
    corona.addColorStop(0,rgb(C.sunCol, 0.3));
    corona.addColorStop(1,rgb(C.skyHor,0));
    ctx.fillStyle=corona;
    ctx.beginPath(); ctx.arc(sunX,sunY,sunR*5,0,Math.PI*2); ctx.fill();
  }

  // Sun rays (summer)
  if(p>0.65){
    const ri = (p-0.65)/0.35;
    const nRays = 12;
    ctx.save(); ctx.globalAlpha = ri*0.12;
    for(let i=0;i<nRays;i++){
      const angle = (i/nRays)*Math.PI*2 + S.time*0.05;
      const rLen  = sunR*lerp(2,5,ri);
      const rW    = sunR*0.25;
      ctx.save(); ctx.translate(sunX,sunY); ctx.rotate(angle);
      const rg = ctx.createLinearGradient(sunR*0.8,0,rLen,0);
      rg.addColorStop(0,rgb(C.sunCol,0.6)); rg.addColorStop(1,rgb(C.sunCol,0));
      ctx.fillStyle=rg;
      ctx.beginPath();
      ctx.moveTo(sunR*0.8,-rW*0.3); ctx.lineTo(rLen,0); ctx.lineTo(sunR*0.8,rW*0.3);
      ctx.fill(); ctx.restore();
    }
    ctx.restore();
  }

  // Sun disk
  const sd = ctx.createRadialGradient(sunX,sunY,0,sunX,sunY,sunR);
  sd.addColorStop(0,rgb(C.sunCol));
  sd.addColorStop(0.7,rgb(C.sunCol,0.9));
  sd.addColorStop(1,`rgba(0,0,0,0)`);
  ctx.fillStyle=sd; ctx.beginPath(); ctx.arc(sunX,sunY,sunR,0,Math.PI*2); ctx.fill();

  // Winter breath/fog on horizon
  if(p<0.4){
    const fi=(0.4-p)/0.4*0.35;
    const fg=ctx.createLinearGradient(0,horizonY-H*0.08,0,horizonY+H*0.04);
    fg.addColorStop(0,`rgba(180,200,230,0)`);
    fg.addColorStop(0.5,rgb(C.fog,fi));
    fg.addColorStop(1,`rgba(180,200,230,0)`);
    ctx.fillStyle=fg; ctx.fillRect(0,horizonY-H*0.08,W,H*0.12);
  }
}

// ── MOUNTAINS / HILLS ────────────────────────────────────────────────────────
function drawMountains(p, vol, C, horizonY){
  const breathe = Math.sin(S.time*lerp(0.2,0.8,vol))*lerp(1,5,vol);

  // Far mountains
  ctx.beginPath(); ctx.moveTo(0,H);
  ctx.lineTo(0, horizonY+8);
  for(let x=0;x<=W;x+=3){
    const nx=x/W;
    const y = horizonY + sn(nx+S.windOffset*0.1,S.time*0.05)*lerp(20,45,vol) + breathe*0.3;
    ctx.lineTo(x,y);
  }
  ctx.lineTo(W,H); ctx.closePath();
  const mg = ctx.createLinearGradient(0,horizonY,0,horizonY+H*0.12);
  const mTop = p<0.5 ? lc(p*2,[100,120,150],[70,100,60]) : lc((p-0.5)*2,[70,100,60],[110,130,60]);
  const mBot = p<0.5 ? lc(p*2,[70,90,120],[50,80,45]) : lc((p-0.5)*2,[50,80,45],[80,100,40]);
  mg.addColorStop(0,rgb(mTop)); mg.addColorStop(1,rgb(mBot));
  ctx.fillStyle=mg; ctx.fill();

  // Snow caps on mountains (winter)
  if(p<0.45){
    const si=(0.45-p)/0.45;
    ctx.save(); ctx.globalAlpha=si*0.9;
    ctx.beginPath(); ctx.moveTo(0,horizonY+8);
    for(let x=0;x<=W;x+=3){
      const nx=x/W;
      const y = horizonY + sn(nx+S.windOffset*0.1,S.time*0.05)*lerp(20,45,vol) + breathe*0.3;
      ctx.lineTo(x, y-si*lerp(5,20,1-p));
    }
    ctx.lineTo(W,horizonY+8); ctx.lineTo(0,horizonY+8); ctx.closePath();
    const sg2=ctx.createLinearGradient(0,horizonY,0,horizonY+H*0.05);
    sg2.addColorStop(0,'rgba(230,240,255,0.95)'); sg2.addColorStop(1,'rgba(200,220,240,0)');
    ctx.fillStyle=sg2; ctx.fill();
    ctx.restore();
  }
}

// ── GROUND ───────────────────────────────────────────────────────────────────
function drawGround(p, vol, C, horizonY){
  const breathe = Math.sin(S.time*lerp(0.2,0.9,vol))*lerp(1,6,vol);

  // Main ground
  ctx.beginPath(); ctx.moveTo(0,H);
  ctx.lineTo(0, horizonY+H*0.08);
  for(let x=0;x<=W;x+=4){
    const nx=x/W;
    const y = horizonY+H*0.08
      + sn(nx*1.3+S.windOffset*0.05,S.time*0.08)*lerp(10,35,vol)
      + breathe*0.5;
    ctx.lineTo(x,y);
  }
  ctx.lineTo(W,H); ctx.closePath();
  const gg=ctx.createLinearGradient(0,horizonY+H*0.06,0,H);
  gg.addColorStop(0,rgb(C.gndTop));
  gg.addColorStop(0.35,rgb(C.gndTop));
  gg.addColorStop(1,rgb(C.gndBot));
  ctx.fillStyle=gg; ctx.fill();

  // Foreground rise
  ctx.beginPath(); ctx.moveTo(0,H);
  ctx.lineTo(0,H*0.78+breathe*0.7);
  for(let x=0;x<=W;x+=4){
    const nx=x/W;
    const y=H*0.78+breathe*0.7
      + sn(nx*1.8+S.windOffset*0.04+5,S.time*0.09)*lerp(8,25,vol);
    ctx.lineTo(x,y);
  }
  ctx.lineTo(W,H); ctx.closePath();
  const fg2=ctx.createLinearGradient(0,H*0.75,0,H);
  const fTop = p<0.3?lc(p/0.3,[170,190,220],[70,95,50]):p<0.7?lc((p-0.3)/0.4,[70,95,50],[90,120,45]):lc((p-0.7)/0.3,[90,120,45],[150,130,55]);
  const fBot = p<0.3?lc(p/0.3,[120,140,175],[40,65,30]):p<0.7?lc((p-0.3)/0.4,[40,65,30],[60,85,30]):lc((p-0.7)/0.3,[60,85,30],[100,85,35]);
  fg2.addColorStop(0,rgb(fTop)); fg2.addColorStop(1,rgb(fBot));
  ctx.fillStyle=fg2; ctx.fill();

  // Ice/snow overlay on ground (winter)
  if(p<0.35){
    const si=ease((0.35-p)/0.35);
    const ig=ctx.createLinearGradient(0,H*0.7,0,H);
    ig.addColorStop(0,`rgba(210,225,245,${si*0.85})`);
    ig.addColorStop(0.4,`rgba(220,235,250,${si*0.7})`);
    ig.addColorStop(1,`rgba(180,200,225,${si*0.9})`);
    ctx.fillStyle=ig; ctx.fillRect(0,H*0.68,W,H*0.32);

    // Ice crack lines
    ctx.save(); ctx.globalAlpha=si*0.2;
    ctx.strokeStyle='rgba(160,190,220,0.8)'; ctx.lineWidth=0.5;
    for(let i=0;i<12;i++){
      ctx.beginPath();
      const sx=((i*137)%1)*W; const sy=H*0.72+((i*73)%100)/100*H*0.25;
      ctx.moveTo(sx,sy);
      ctx.lineTo(sx+(Math.random()-0.5)*120, sy+30+Math.random()*60);
      ctx.stroke();
    }
    ctx.restore();
  }
}

// ── ICICLES ──────────────────────────────────────────────────────────────────
function drawIcicles(p, C, horizonY){
  const icicleIntensity = ease((0.3-p)/0.3);
  if(icicleIntensity<0.01) return;

  // Along mountain tops
  const groundY = horizonY + H*0.09;

  ICICLES.forEach(ic=>{
    const x = ic.xn*W;
    const baseY = groundY + sn(ic.xn*1.3,S.time*0.08)*lerp(6,20,S.vol);
    const len = ic.len * H * icicleIntensity * lerp(0.6,1.4,icicleIntensity);
    const w = ic.w * icicleIntensity;

    // Drip animation (slow melt if p>0.12)
    const drip = p>0.12 ? Math.sin(S.time*0.5+ic.xn*10)*2*((p-0.12)/0.18) : 0;

    ctx.save();
    // Main icicle body
    const ig=ctx.createLinearGradient(x,baseY,x,baseY+len+drip);
    ig.addColorStop(0,`rgba(200,220,245,${icicleIntensity*0.9})`);
    ig.addColorStop(0.7,`rgba(180,210,240,${icicleIntensity*0.7})`);
    ig.addColorStop(1,`rgba(160,200,235,0)`);
    ctx.fillStyle=ig;
    ctx.beginPath();
    ctx.moveTo(x-w*0.5, baseY);
    ctx.lineTo(x+w*0.5, baseY);
    ctx.lineTo(x+w*0.15, baseY+len+drip);
    ctx.lineTo(x-w*0.15, baseY+len+drip);
    ctx.closePath(); ctx.fill();

    // Highlight edge
    ctx.strokeStyle=`rgba(230,245,255,${icicleIntensity*0.5})`;
    ctx.lineWidth=0.5;
    ctx.beginPath(); ctx.moveTo(x-w*0.3,baseY); ctx.lineTo(x-w*0.1,baseY+len*0.7+drip); ctx.stroke();

    // Drip drop
    if(drip>1){
      ctx.beginPath(); ctx.arc(x, baseY+len+drip+3, 2, 0,Math.PI*2);
      ctx.fillStyle=`rgba(180,215,245,${icicleIntensity*0.6})`; ctx.fill();
    }
    ctx.restore();
  });

  // Foreground icicles (larger)
  for(let i=0;i<8;i++){
    const x = ((i*0.13+0.03)%1)*W;
    const baseY = H*0.78;
    const len = (0.08+((i*47)%100)/100*0.1)*H*icicleIntensity;
    const w = (5+((i*31)%10))*icicleIntensity;
    const drip = p>0.1 ? Math.abs(Math.sin(S.time*0.7+i*1.4))*8*((p)/(0.3)) : 0;

    ctx.save();
    const ig2=ctx.createLinearGradient(x,baseY,x,baseY+len+drip);
    ig2.addColorStop(0,`rgba(215,235,255,${icicleIntensity*0.95})`);
    ig2.addColorStop(1,`rgba(190,220,245,0)`);
    ctx.fillStyle=ig2;
    ctx.beginPath();
    ctx.moveTo(x-w*0.5,baseY); ctx.lineTo(x+w*0.5,baseY);
    ctx.lineTo(x+w*0.1,baseY+len+drip); ctx.lineTo(x-w*0.1,baseY+len+drip);
    ctx.closePath(); ctx.fill();
    ctx.restore();
  }
}

// ── VEGETATION (trees, grass, flowers) ───────────────────────────────────────
function drawVegetation(p, vol, C, mx, horizonY){
  if(p<0.15) return; // frozen — no life
  const vegI = clamp((p-0.15)/0.35, 0, 1); // 0→1 as spring arrives
  const windSway = S.windSpeed*600 * vol;
  const parallaxX = (mx-0.5)*15;

  TREES.forEach((tr,i)=>{
    const x = tr.xn*W + parallaxX*(0.5+tr.size*0.3);
    const groundY = H*0.72 + sn(tr.xn*1.3,S.time*0.05)*lerp(3,12,vol);
    const baseH = H*(0.08+tr.size*0.14)*vegI;
    const trunkW = baseH*0.06;

    // Trunk
    ctx.save();
    const tkCol = p<0.5
      ? lc(p*2,[60,45,35],[50,38,28])
      : lc((p-0.5)*2,[50,38,28],[70,55,30]);
    ctx.fillStyle=rgb(tkCol);
    ctx.fillRect(x-trunkW*0.5, groundY-baseH, trunkW, baseH);

    // Canopy sway
    const sway = Math.sin(S.time*(0.8+tr.phase*0.3)+tr.phase)*windSway*tr.size*0.012;

    ctx.translate(x+sway, groundY-baseH);

    // Summer flowers / full canopy
    const canopyR = baseH*(0.55+Math.sin(tr.phase)*0.1);

    // Leaf color
    let leafCol;
    if(p<0.35)       leafCol=lc((p-0.15)/0.2,[180,200,140],[80,140,50]);
    else if(p<0.65)  leafCol=lc((p-0.35)/0.3,[80,140,50],[55,130,40]);
    else if(p<0.85)  leafCol=lc((p-0.65)/0.2,[55,130,40],[200,160,40]);
    else             leafCol=lc((p-0.85)/0.15,[200,160,40],[220,130,40]);

    // Multiple canopy blobs
    for(let b=0;b<3;b++){
      const bx=(b-1)*canopyR*0.35;
      const by=b===1?-canopyR*0.2:canopyR*0.05;
      const br=canopyR*(b===1?1:0.72);
      const cg=ctx.createRadialGradient(bx,by,0,bx,by,br);
      const lighter=lc(0.3,leafCol,[255,255,255]);
      cg.addColorStop(0,rgb(lighter,vegI*0.95));
      cg.addColorStop(0.7,rgb(leafCol,vegI*0.9));
      cg.addColorStop(1,rgb(leafCol,vegI*0.3));
      ctx.fillStyle=cg;
      ctx.beginPath(); ctx.arc(bx,by,br,0,Math.PI*2); ctx.fill();
    }

    // Summer blossoms
    if(p>0.6){
      const bi=(p-0.6)/0.4;
      const nBlossoms=Math.floor(bi*8);
      for(let b=0;b<nBlossoms;b++){
        const bAngle=(b/nBlossoms)*Math.PI*2+S.time*0.2+tr.phase;
        const bDist=canopyR*(0.4+((b*37)%100)/100*0.4);
        const bx2=Math.cos(bAngle)*bDist;
        const by2=Math.sin(bAngle)*bDist*0.5-canopyR*0.1;
        ctx.beginPath(); ctx.arc(bx2,by2,3+bi*2,0,Math.PI*2);
        const bHue=p>0.8?35:340;
        ctx.fillStyle=`hsla(${bHue},85%,75%,${bi*0.85})`; ctx.fill();
      }
    }
    ctx.restore();
  });

  // Grass blades (foreground)
  if(vegI>0.1){
    const nGrass=120;
    for(let i=0;i<nGrass;i++){
      const gx=((i*73.7)%1)*W;
      const groundY=H*0.79+sn(gx/W*1.8,S.time*0.05)*lerp(3,10,vol);
      const gh=H*(0.025+((i*31)%100)/100*0.04)*vegI;
      const gsway=Math.sin(S.time*(0.9+((i*17)%10)/10*0.6)+i*0.5)*windSway*0.015;

      let gCol;
      if(p<0.5) gCol=lc((p-0.15)/0.35,[150,180,100],[60,140,40]);
      else if(p<0.8) gCol=lc((p-0.5)/0.3,[60,140,40],[100,150,40]);
      else gCol=lc((p-0.8)/0.2,[100,150,40],[180,150,50]);

      ctx.save();
      ctx.translate(gx,groundY);
      ctx.strokeStyle=rgb(gCol,vegI*0.7);
      ctx.lineWidth=1+((i*11)%10)/10;
      ctx.beginPath(); ctx.moveTo(0,0); ctx.quadraticCurveTo(gsway*0.5,−gh*0.5,gsway,−gh);
      ctx.stroke();
      ctx.restore();
    }
  }

  // Summer wildflowers
  if(p>0.55){
    const fi=(p-0.55)/0.45;
    for(let i=0;i<40;i++){
      const fx=((i*97.3)%1)*W;
      const fy=H*0.79+((i*43)%100)/100*H*0.1+sn(fx/W,S.time*0.04)*5;
      const sway2=Math.sin(S.time*(1+((i*23)%10)/10)+i)*windSway*0.012;
      ctx.save(); ctx.translate(fx+sway2,fy);
      ctx.strokeStyle=`rgba(60,120,40,${fi*0.6})`; ctx.lineWidth=0.8;
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,−H*0.02*fi); ctx.stroke();
      const hue=[330,50,280,120,200][i%5];
      ctx.beginPath(); ctx.arc(0,−H*0.02*fi,2+fi*2,0,Math.PI*2);
      ctx.fillStyle=`hsla(${hue},80%,65%,${fi*0.85})`; ctx.fill();
      ctx.restore();
    }
  }
}

// ── PARTICLES (snow / petals / fireflies) ────────────────────────────────────
function drawParticles(p, vol, C){
  const windForce = S.windSpeed * 2.5;
  const stormTilt = vol * 0.4;

  particles.forEach((pt,i)=>{
    // Update
    pt.vy = lerp(0.0002, 0.001, vol) * (0.5+pt.r*0.15);
    pt.vx = windForce * (1+Math.sin(pt.phase+S.time*0.5)*0.3);
    pt.x += pt.vx + Math.sin(S.time*0.7+pt.phase)*pt.wobble*(1-stormTilt*0.5);
    pt.y += pt.vy;
    if(pt.y>1) { pt.y=0; pt.x=Math.random(); }
    if(pt.x>1) pt.x=0;
    if(pt.x<0) pt.x=1;

    const sx=pt.x*W, sy=pt.y*H;

    if(p<0.35){
      // SNOW
      const si=ease(clamp((0.35-p)/0.35+0.1,0,1));
      const size=pt.r*(0.5+si);
      ctx.save(); ctx.globalAlpha=pt.opacity*si*0.85;
      // Snowflake shape
      if(pt.r>1.8){
        ctx.strokeStyle='rgba(220,235,255,0.9)'; ctx.lineWidth=0.5;
        for(let arm=0;arm<6;arm++){
          const a=(arm/6)*Math.PI*2;
          ctx.beginPath(); ctx.moveTo(sx,sy);
          ctx.lineTo(sx+Math.cos(a)*size*3,sy+Math.sin(a)*size*3); ctx.stroke();
        }
      } else {
        ctx.beginPath(); ctx.arc(sx,sy,size,0,Math.PI*2);
        ctx.fillStyle='rgba(220,235,255,0.85)'; ctx.fill();
      }
      ctx.restore();
    } else if(p>0.5 && p<0.85){
      // PETALS / BLOSSOMS
      const pi2=clamp((p-0.5)/0.35,0,1)*clamp((0.85-p)/0.35,0,1);
      if(pi2>0.05){
        ctx.save(); ctx.globalAlpha=pt.opacity*pi2*0.7;
        ctx.translate(sx,sy); ctx.rotate(S.time*0.5+pt.phase);
        const hue=p<0.7?340:50;
        ctx.fillStyle=`hsla(${hue},80%,78%,1)`;
        ctx.beginPath();
        ctx.ellipse(0,0,pt.r*1.5,pt.r*0.8,0,0,Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }
  });
}

// ── FIREFLIES ────────────────────────────────────────────────────────────────
function drawFireflies(p, vol){
  const fi=(p-0.6)/0.4;
  if(fi<0.01) return;
  for(let i=0;i<25;i++){
    const t=S.time*0.3+i*2.7;
    const fx=((i*137.5+Math.sin(t)*0.08)%1)*W;
    const fy=H*(0.55+((i*91)%100)/100*0.35)+Math.sin(t*1.3+i)*H*0.04;
    const glow=Math.abs(Math.sin(S.time*(0.8+i*0.1)+i*1.5));
    const sz=1.5+glow*2;
    ctx.save();
    const fg3=ctx.createRadialGradient(fx,fy,0,fx,fy,sz*4);
    fg3.addColorStop(0,`rgba(200,255,130,${fi*glow*0.8})`);
    fg3.addColorStop(1,`rgba(180,255,80,0)`);
    ctx.fillStyle=fg3; ctx.beginPath(); ctx.arc(fx,fy,sz*4,0,Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(fx,fy,sz,0,Math.PI*2);
    ctx.fillStyle=`rgba(220,255,150,${fi*glow*0.95})`; ctx.fill();
    ctx.restore();
  }
}

// ── WIND LINES ───────────────────────────────────────────────────────────────
function drawWindLines(vol, p){
  if(vol<0.3) return;
  const wi=(vol-0.3)/0.7;
  const nLines=Math.floor(wi*25);
  ctx.save(); ctx.globalAlpha=wi*0.12;
  for(let i=0;i<nLines;i++){
    const ly=(((i*73.3)+S.windOffset*300+i*S.windSpeed*8000)%1)*H;
    const lx=((i*137+S.windOffset*200)%1)*W;
    const len=lerp(30,180,vol)*(0.5+Math.random()*0.5);
    ctx.strokeStyle=p<0.35?'rgba(200,220,255,0.6)':'rgba(255,255,255,0.4)';
    ctx.lineWidth=0.4+wi*0.6;
    ctx.beginPath(); ctx.moveTo(lx,ly); ctx.lineTo(lx+len,ly+len*0.06); ctx.stroke();
  }
  ctx.restore();
}

// ── PRICE TEXT ───────────────────────────────────────────────────────────────
function drawPriceInLandscape(p, C, horizonY){
  if(!S.priceStr) return;
  const textY = H*(0.635 + (1-p)*0.03);
  const fs = Math.floor(W*0.052);
  ctx.save();
  ctx.translate(W*0.5, textY);
  ctx.transform(1, 0, 0.008, 0.82, 0, 0);

  // Shadow
  ctx.font=`400 ${fs}px 'EB Garamond',serif`;
  ctx.textAlign='center'; ctx.textBaseline='middle';

  let shadowCol, textCol, strokeCol;
  if(p<0.3){
    // Ice: cold blue-grey text
    shadowCol=[100,130,170]; textCol=[185,210,240]; strokeCol=[220,240,255];
  } else if(p<0.6){
    // Spring: earthy green-grey
    shadowCol=[30,55,30]; textCol=[160,190,130]; strokeCol=[200,220,180];
  } else {
    // Summer: warm gold
    shadowCol=[80,55,20]; textCol=[240,210,120]; strokeCol=[255,245,200];
  }

  ctx.fillStyle=rgb(shadowCol,0.8); ctx.fillText(S.priceStr,3,5);
  ctx.fillStyle=rgb(textCol,lerp(0.55,0.9,p)); ctx.fillText(S.priceStr,0,0);
  ctx.strokeStyle=rgb(strokeCol,lerp(0.1,0.35,p));
  ctx.lineWidth=0.5; ctx.strokeText(S.priceStr,0,-0.5);
  ctx.restore();
}

// ── PULSES ───────────────────────────────────────────────────────────────────
function drawPulses(p, C, vol){
  S.pulses=S.pulses.filter(pl=>pl.life>0.01);
  S.pulses.forEach(pl=>{
    pl.life=lerp(pl.life,0,0.04); pl.r+=lerp(1.5,5,vol);
    const sx=pl.x*W, sy=pl.y*H, mx2=W*0.4;
    for(let r2=0;r2<3;r2++){
      const rr=pl.r-r2*20; if(rr<0) continue;
      const a=pl.life*(1-rr/mx2)*(0.18-r2*0.05); if(a<=0) continue;
      ctx.beginPath(); ctx.arc(sx,sy,rr,0,Math.PI*2);
      ctx.strokeStyle=p<0.3
        ? `rgba(180,220,255,${a})`
        : p>0.65
        ? `rgba(255,220,100,${a})`
        : `rgba(180,230,160,${a})`;
      ctx.lineWidth=lerp(2,0.5,r2/3); ctx.stroke();
    }
  });
}

// ── VIGNETTE ─────────────────────────────────────────────────────────────────
function drawVignette(p){
  const vg=ctx.createRadialGradient(W/2,H/2,W*0.08,W/2,H/2,W*0.88);
  const va=p<0.5?lerp(0.75,0.55,p*2):lerp(0.55,0.35,(p-0.5)*2);
  vg.addColorStop(0,'transparent');
  vg.addColorStop(1,`rgba(0,0,0,${va})`);
  ctx.fillStyle=vg; ctx.fillRect(0,0,W,H);

  // Top darkening (winter heaviness)
  if(p<0.4){
    const tg=ctx.createLinearGradient(0,0,0,H*0.25);
    tg.addColorStop(0,`rgba(0,5,15,${(0.4-p)/0.4*0.5})`);
    tg.addColorStop(1,'transparent');
    ctx.fillStyle=tg; ctx.fillRect(0,0,W,H*0.25);
  }
}

// ── CURSOR STYLE ─────────────────────────────────────────────────────────────
function updateCursor(){
  const p=S.smoothPos;
  const h=p<0.5?lerp(210,140,p*2):lerp(140,45,(p-0.5)*2);
  ring.style.borderColor=`hsla(${h},60%,70%,0.35)`;
}

// ═══════════════════════════════════════════════════════════
//  BOOT
// ═══════════════════════════════════════════════════════════
function tick(){ updateCursor(); requestAnimationFrame(tick); }
draw();
tick();
</script>
</body>
</html>

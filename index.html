<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Bitcoin Desert</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: #000;
    cursor: none;
  }

  canvas {
    display: block;
    position: fixed;
    top: 0; left: 0;
  }

  #ui {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 10;
  }

  /* Custom cursor */
  #cursor {
    position: fixed;
    width: 8px; height: 8px;
    border-radius: 50%;
    background: rgba(255,255,255,0.9);
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 100;
    transition: transform 0.1s, opacity 0.3s;
    mix-blend-mode: difference;
  }

  #cursor-ring {
    position: fixed;
    width: 32px; height: 32px;
    border-radius: 50%;
    border: 1px solid rgba(255,255,255,0.3);
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 99;
    transition: width 0.3s, height 0.3s, border-color 0.3s;
  }

  /* Loading */
  #loader {
    position: fixed;
    inset: 0;
    background: #000;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 200;
    transition: opacity 1.5s ease;
  }

  #loader.fade {
    opacity: 0;
    pointer-events: none;
  }

  .loader-text {
    font-family: 'Georgia', serif;
    color: rgba(255,255,255,0.2);
    font-size: 0.7rem;
    letter-spacing: 0.5em;
    text-transform: uppercase;
    animation: loader-pulse 2s ease-in-out infinite;
  }

  @keyframes loader-pulse {
    0%, 100% { opacity: 0.2; }
    50% { opacity: 0.7; }
  }

  /* Footer */
  #footer {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    height: 72px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0;
    pointer-events: all;
    opacity: 0;
    transition: opacity 1.5s ease;
    z-index: 20;
  }

  #footer.visible { opacity: 1; }

  .footer-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
    padding: 0 3.5vw;
    position: relative;
    cursor: pointer;
  }

  .footer-item + .footer-item::before {
    content: '';
    position: absolute;
    left: 0; top: 20%; height: 60%;
    width: 1px;
    background: rgba(255,255,255,0.08);
  }

  .footer-label {
    font-family: 'Georgia', serif;
    font-size: 0.45rem;
    letter-spacing: 0.45em;
    text-transform: uppercase;
    color: rgba(255,255,255,0.25);
    user-select: none;
    transition: color 0.3s;
  }

  .footer-item:hover .footer-label { color: rgba(255,255,255,0.5); }

  .footer-value {
    font-family: 'Georgia', serif;
    font-size: clamp(0.8rem, 1.8vw, 1.15rem);
    letter-spacing: 0.06em;
    color: rgba(255,255,255,0.55);
    border: none;
    background: transparent;
    outline: none;
    text-align: center;
    width: 16ch;
    cursor: pointer;
    transition: color 0.3s, border-bottom 0.2s;
    caret-color: rgba(255,255,255,0.6);
    border-bottom: 1px solid transparent;
  }

  .footer-value:hover {
    color: rgba(255,255,255,0.8);
    border-bottom: 1px solid rgba(255,255,255,0.15);
  }

  .footer-value:focus {
    color: #fff;
    border-bottom: 1px solid rgba(255,255,255,0.4);
    cursor: text;
  }

  /* current price gets slightly brighter */
  .footer-item.current .footer-value {
    color: rgba(255,240,200,0.7);
    font-size: clamp(0.9rem, 2vw, 1.25rem);
  }

  .footer-item.current .footer-value:focus { color: #fff; }

  /* Edited flash */
  @keyframes value-flash {
    0%   { color: rgba(255,220,100,0.9); }
    100% { color: rgba(255,255,255,0.55); }
  }
  .footer-value.flash { animation: value-flash 0.8s ease forwards; }

  /* Hint */
  #hint {
    position: fixed;
    bottom: 78px;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Georgia', serif;
    font-size: 0.5rem;
    letter-spacing: 0.4em;
    color: rgba(255,255,255,0.0);
    text-transform: uppercase;
    white-space: nowrap;
    transition: color 3s ease;
    pointer-events: none;
  }

  #hint.visible { color: rgba(255,255,255,0.14); }
</style>
</head>
<body>

<div id="loader"><div class="loader-text">Reading the desert</div></div>

<div id="cursor"></div>
<div id="cursor-ring"></div>

<canvas id="c"></canvas>

<div id="ui">
  <div id="hint">Move · Scroll · Click the sand</div>
</div>

<div id="footer">
  <div class="footer-item low">
    <span class="footer-label">Day Low</span>
    <input class="footer-value" id="f-low" type="text" inputmode="numeric" value="—"/>
  </div>
  <div class="footer-item current">
    <span class="footer-label">Current</span>
    <input class="footer-value" id="f-price" type="text" inputmode="numeric" value="—"/>
  </div>
  <div class="footer-item high">
    <span class="footer-label">Day High</span>
    <input class="footer-value" id="f-high" type="text" inputmode="numeric" value="—"/>
  </div>
</div>

<script>
// ─── CONFIG ─────────────────────────────────────────────────────────────────
const CFG = {
  API: 'https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=bitcoin',
  REFRESH: 30000,
};

// ─── STATE ───────────────────────────────────────────────────────────────────
const S = {
  price: 0, high: 0, low: 0,
  pos: 0.5,        // (price-low)/(high-low)
  volatility: 0.5, // normalized
  targetPos: 0.5,
  smoothPos: 0.5,
  mouse: { x: 0.5, y: 0.5 },
  targetMouse: { x: 0.5, y: 0.5 },
  scroll: 0,
  pulses: [],
  time: 0,
  loaded: false,
  priceStr: '',
};

// ─── CANVAS ──────────────────────────────────────────────────────────────────
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// ─── FOOTER ELEMENTS ─────────────────────────────────────────────────────────
const fLow   = document.getElementById('f-low');
const fPrice = document.getElementById('f-price');
const fHigh  = document.getElementById('f-high');
const footer = document.getElementById('footer');

function fmt(n) {
  return new Intl.NumberFormat('en-US', {
    style: 'currency', currency: 'USD',
    minimumFractionDigits: 0, maximumFractionDigits: 0
  }).format(n);
}

function parseInput(str) {
  return parseFloat(String(str).replace(/[^0-9.]/g, ''));
}

function recalc() {
  const range = S.high - S.low || 1;
  S.pos = Math.max(0, Math.min(1, (S.price - S.low) / range));
  S.volatility = Math.min(1, range / S.price * 15);
  S.targetPos = S.pos;
  S.priceStr = fmt(S.price);
}

function flashInput(el) {
  el.classList.remove('flash');
  void el.offsetWidth;
  el.classList.add('flash');
}

function updateFooterDisplay() {
  fLow.value   = fmt(S.low);
  fHigh.value  = fmt(S.high);
  fPrice.value = fmt(S.price);
}

function bindInput(el, key) {
  el.addEventListener('focus', () => {
    el.value = Math.round(S[key]);
    el.select();
  });
  el.addEventListener('blur', () => {
    const v = parseInput(el.value);
    if (!isNaN(v) && v > 0) {
      S[key] = v;
      recalc();
      flashInput(el);
    }
    updateFooterDisplay();
  });
  el.addEventListener('keydown', e => {
    if (e.key === 'Enter') el.blur();
    if (e.key === 'Escape') { updateFooterDisplay(); el.blur(); }
  });
  el.addEventListener('click', e => e.stopPropagation());
  el.addEventListener('mousedown', e => e.stopPropagation());
}

bindInput(fLow,   'low');
bindInput(fPrice, 'price');
bindInput(fHigh,  'high');

// ─── API ─────────────────────────────────────────────────────────────────────
async function fetchData() {
  try {
    const r = await fetch(CFG.API);
    const d = await r.json();
    const b = d[0];
    S.price = b.current_price;
    S.high  = b.high_24h;
    S.low   = b.low_24h;
    recalc();
    updateFooterDisplay();

    if (!S.loaded) {
      S.loaded = true;
      S.smoothPos = S.pos;
      document.getElementById('loader').classList.add('fade');
      setTimeout(() => {
        const loaderEl = document.getElementById('loader');
        if (loaderEl) loaderEl.remove();
        footer.classList.add('visible');
        setTimeout(() => {
          const hintEl = document.getElementById('hint');
          if (hintEl) hintEl.classList.add('visible');
        }, 2000);
      }, 1600);
    }
  } catch(e) {
    // retry silently
  }
}
fetchData();
setInterval(fetchData, CFG.REFRESH);

// ─── INPUT ───────────────────────────────────────────────────────────────────
const cursor = document.getElementById('cursor');
const ring   = document.getElementById('cursor-ring');

window.addEventListener('mousemove', e => {
  cursor.style.left = e.clientX + 'px';
  cursor.style.top  = e.clientY + 'px';
  ring.style.left   = e.clientX + 'px';
  ring.style.top    = e.clientY + 'px';
  S.targetMouse.x = e.clientX / W;
  S.targetMouse.y = e.clientY / H;
});

window.addEventListener('wheel', e => {
  S.scroll += e.deltaY * 0.0003;
  S.scroll  = Math.max(-0.3, Math.min(0.3, S.scroll));
});

window.addEventListener('click', e => {
  S.pulses.push({
    x: e.clientX / W,
    y: e.clientY / H,
    r: 0, life: 1, birth: S.time
  });
});

// ─── MATH HELPERS ────────────────────────────────────────────────────────────
const lerp   = (a, b, t) => a + (b - a) * t;
const clamp  = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
const noise  = (x, y, t) => Math.sin(x * 3.1 + t * 0.7) * Math.cos(y * 2.3 - t * 0.5)
                           + Math.sin(x * 1.7 - t * 0.3) * 0.5;

// ─── COLOR PALETTE ───────────────────────────────────────────────────────────
// pos=0 (low) → pre-dusk, cold blue-violet desert
// pos=1 (high) → scorching noon, bleached gold
function palette(pos, vol) {
  // Sky gradient stops
  const sky = {
    top:    lerpColor(pos, [10, 18, 40],    [255, 240, 200]),
    mid:    lerpColor(pos, [30, 45, 80],    [255, 200, 100]),
    horizon:lerpColor(pos, [80, 90, 120],   [255, 160, 60]),
    sun:    lerpColor(pos, [100, 130, 200], [255, 255, 220]),
  };
  const sand = {
    far:    lerpColor(pos, [60, 65, 100],   [230, 200, 140]),
    near:   lerpColor(pos, [40, 45, 75],    [200, 170, 100]),
    shadow: lerpColor(pos, [20, 22, 45],    [120, 100, 60]),
  };
  const sunCol = lerpColor(pos, [80, 100, 200], [255, 255, 200]);
  const fogCol = lerpColor(pos, [20, 30, 70],   [255, 230, 160]);
  return { sky, sand, sunCol, fogCol };
}

function lerpColor(t, a, b) {
  return [
    Math.round(lerp(a[0], b[0], t)),
    Math.round(lerp(a[1], b[1], t)),
    Math.round(lerp(a[2], b[2], t)),
  ];
}

function rgb([r,g,b], a=1) {
  return a < 1 ? `rgba(${r},${g},${b},${a})` : `rgb(${r},${g},${b})`;
}

// ─── DRAW ─────────────────────────────────────────────────────────────────────
function draw() {
  S.time += 0.008;

  // Smooth
  S.smoothPos = lerp(S.smoothPos, S.targetPos + S.scroll, 0.015);
  S.smoothPos = clamp(S.smoothPos, 0, 1);
  S.mouse.x = lerp(S.mouse.x, S.targetMouse.x, 0.06);
  S.mouse.y = lerp(S.mouse.y, S.targetMouse.y, 0.06);

  if (!S.loaded) { requestAnimationFrame(draw); return; }

  const p   = S.smoothPos;
  const vol = S.volatility;
  const C   = palette(p, vol);
  const mx  = S.mouse.x;
  const my  = S.mouse.y;

  ctx.clearRect(0, 0, W, H);

  // ── Sky ──────────────────────────────────────────────────────────────────
  const horizonY = H * (0.42 + (1 - p) * 0.12);
  const skyGrad = ctx.createLinearGradient(0, 0, 0, horizonY);
  skyGrad.addColorStop(0,   rgb(C.sky.top));
  skyGrad.addColorStop(0.6, rgb(C.sky.mid));
  skyGrad.addColorStop(1,   rgb(C.sky.horizon));
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, horizonY);

  // ── Sun ───────────────────────────────────────────────────────────────────
  const sunX = W * (0.5 + (mx - 0.5) * 0.06);
  // sun height: high pos → high in sky; low pos → near horizon
  const sunY = lerp(horizonY * 1.05, horizonY * 0.2, p);
  const sunR = lerp(28, 48, p) + vol * 8;

  // Atmospheric haze around sun
  const hazeR = sunR * lerp(3.5, 6, 1 - p);
  const hazeGrad = ctx.createRadialGradient(sunX, sunY, sunR * 0.5, sunX, sunY, hazeR);
  hazeGrad.addColorStop(0,   rgb(C.sunCol, lerp(0.6, 0.25, p)));
  hazeGrad.addColorStop(1,   rgb(C.sky.horizon, 0));
  ctx.fillStyle = hazeGrad;
  ctx.beginPath();
  ctx.arc(sunX, sunY, hazeR, 0, Math.PI * 2);
  ctx.fill();

  // Sun disk
  const sunGrad = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunR);
  sunGrad.addColorStop(0, rgb(C.sunCol));
  sunGrad.addColorStop(0.7, rgb(C.sunCol, 0.9));
  sunGrad.addColorStop(1, rgb(C.sunCol, 0));
  ctx.fillStyle = sunGrad;
  ctx.beginPath();
  ctx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
  ctx.fill();

  // ── Heat shimmer (high volatility + high pos) ─────────────────────────────
  if (p > 0.4 && vol > 0.2) {
    drawHeatShimmer(horizonY, p, vol);
  }

  // ── Dust / atmosphere particles ────────────────────────────────────────────
  drawDust(p, vol, C);

  // ── Desert dunes ─────────────────────────────────────────────────────────
  drawDunes(horizonY, p, vol, C, mx, my);

  // ── Price inscription in sand ─────────────────────────────────────────────
  drawPrice(horizonY, p, C);

  // ── Pulse rings ───────────────────────────────────────────────────────────
  drawPulses(p, C);

  // ── Vignette ─────────────────────────────────────────────────────────────
  drawVignette(p);

  requestAnimationFrame(draw);
}

function drawHeatShimmer(horizonY, p, vol) {
  const intensity = (p - 0.4) / 0.6 * vol;
  const bands = Math.floor(intensity * 8) + 2;
  for (let i = 0; i < bands; i++) {
    const shimY = horizonY - Math.sin(S.time * 1.2 + i * 0.9) * 12 * intensity;
    const shimH = lerp(1, 4, intensity);
    const shimAlpha = 0.04 + Math.sin(S.time * 2 + i) * 0.02;
    ctx.fillStyle = `rgba(255,230,150,${shimAlpha * intensity})`;
    ctx.fillRect(0, shimY, W, shimH);
  }
}

const dustParticles = Array.from({length: 80}, () => ({
  x: Math.random(), y: Math.random(), r: Math.random() * 1.8 + 0.3,
  speed: Math.random() * 0.0003 + 0.0001, phase: Math.random() * Math.PI * 2
}));

function drawDust(p, vol, C) {
  const activity = vol * p * 0.8 + 0.1;
  dustParticles.forEach(d => {
    d.x += d.speed * activity * (0.5 + Math.sin(S.time * 0.5 + d.phase) * 0.5);
    if (d.x > 1) d.x = 0;
    const screenY = d.y * H * 0.55 + H * 0.05;
    const screenX = d.x * W;
    const a = (0.03 + vol * 0.07) * (1 - d.y * 0.5);
    ctx.beginPath();
    ctx.arc(screenX, screenY, d.r, 0, Math.PI * 2);
    ctx.fillStyle = rgb(C.sand.far, a);
    ctx.fill();
  });
}

function drawDunes(horizonY, p, vol, C, mx, my) {
  const parallaxX = (mx - 0.5) * 20;
  const breathe = Math.sin(S.time * lerp(0.3, 1.2, vol)) * lerp(2, 8, vol);

  // Far dune layer
  ctx.beginPath();
  ctx.moveTo(0, H);
  ctx.lineTo(0, horizonY + 5);
  for (let x = 0; x <= W; x += 4) {
    const nx = x / W;
    const y = horizonY
      + Math.sin(nx * 4.2 + S.time * 0.15 + parallaxX * 0.003) * lerp(8, 22, vol)
      + Math.sin(nx * 7.1 - S.time * 0.08) * lerp(4, 12, vol)
      + breathe * 0.4;
    ctx.lineTo(x, y);
  }
  ctx.lineTo(W, H); ctx.closePath();
  const farGrad = ctx.createLinearGradient(0, horizonY, 0, H);
  farGrad.addColorStop(0, rgb(C.sand.far));
  farGrad.addColorStop(1, rgb(C.sand.shadow));
  ctx.fillStyle = farGrad;
  ctx.fill();

  // Mid dune
  ctx.beginPath();
  ctx.moveTo(0, H);
  ctx.lineTo(0, horizonY + H * 0.07);
  for (let x = 0; x <= W; x += 4) {
    const nx = x / W;
    const y = horizonY + H * 0.07
      + Math.sin(nx * 3.1 + S.time * 0.1 + parallaxX * 0.005) * lerp(15, 40, vol)
      + Math.sin(nx * 5.7 - S.time * 0.06) * lerp(8, 20, vol)
      + breathe * 0.6;
    ctx.lineTo(x, y);
  }
  ctx.lineTo(W, H); ctx.closePath();
  const midGrad = ctx.createLinearGradient(0, horizonY + H * 0.05, 0, H);
  midGrad.addColorStop(0, rgb(C.sand.near));
  midGrad.addColorStop(0.4, rgb(C.sand.near));
  midGrad.addColorStop(1, rgb(C.sand.shadow));
  ctx.fillStyle = midGrad;
  ctx.fill();

  // Near dune (foreground)
  ctx.beginPath();
  ctx.moveTo(0, H);
  ctx.lineTo(-20, H * 0.72 + breathe);
  ctx.bezierCurveTo(
    W * 0.15, H * 0.62 + breathe + parallaxX * 0.1,
    W * 0.35, H * 0.58 + breathe * 1.2,
    W * 0.5 + parallaxX * 0.5, H * 0.6 + breathe
  );
  ctx.bezierCurveTo(
    W * 0.65 + parallaxX * 0.3, H * 0.62 + breathe * 0.8,
    W * 0.82, H * 0.68 + breathe,
    W + 20, H * 0.74 + breathe * 0.5
  );
  ctx.lineTo(W, H); ctx.closePath();
  const nearGrad = ctx.createLinearGradient(0, H * 0.58, 0, H);
  nearGrad.addColorStop(0, rgb(C.sand.shadow));
  nearGrad.addColorStop(0.3, rgb(C.sand.near));
  nearGrad.addColorStop(1, rgb(C.sand.shadow));
  ctx.fillStyle = nearGrad;
  ctx.fill();

  // Dune crest highlight
  ctx.beginPath();
  ctx.moveTo(-20, H * 0.72 + breathe);
  ctx.bezierCurveTo(
    W * 0.15, H * 0.62 + breathe + parallaxX * 0.1,
    W * 0.35, H * 0.58 + breathe * 1.2,
    W * 0.5 + parallaxX * 0.5, H * 0.6 + breathe
  );
  ctx.bezierCurveTo(
    W * 0.65 + parallaxX * 0.3, H * 0.62 + breathe * 0.8,
    W * 0.82, H * 0.68 + breathe,
    W + 20, H * 0.74 + breathe * 0.5
  );
  ctx.strokeStyle = rgb([255,240,200], lerp(0.05, 0.25, p));
  ctx.lineWidth = lerp(0.5, 2, p);
  ctx.stroke();
}

function drawPrice(horizonY, p, C) {
  if (!S.priceStr) return;

  const sandY = H * (0.65 + (1 - p) * 0.04);
  const fontSize = Math.floor(W * 0.055);

  // Sand-engraved style — the price IS the landscape
  ctx.save();
  ctx.translate(W * 0.5, sandY);

  // Subtle perspective tilt
  ctx.transform(1, 0, 0.01, 0.85, 0, 0);

  // Shadow below (depth in sand)
  ctx.font = `300 ${fontSize}px 'Georgia', serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.letterSpacing = '0.12em';
  ctx.fillStyle = rgb(C.sand.shadow, 0.9);
  ctx.fillText(S.priceStr, 3, 5);

  // The engraved text — color blends into sand
  const textColor = lerpColor(p, [180, 185, 220], [220, 195, 130]);
  ctx.fillStyle = rgb(textColor, lerp(0.55, 0.85, p));
  ctx.fillText(S.priceStr, 0, 0);

  // Thin highlight on top edge (sun raking across inscription)
  ctx.strokeStyle = rgb([255,255,240], lerp(0.08, 0.3, p));
  ctx.lineWidth = 0.5;
  ctx.strokeText(S.priceStr, 0, -0.5);

  ctx.restore();
}

function drawPulses(p, C) {
  S.pulses = S.pulses.filter(pulse => pulse.life > 0.01);
  S.pulses.forEach(pulse => {
    pulse.life = lerp(pulse.life, 0, 0.04);
    pulse.r += lerp(1, 4, S.volatility);

    const screenX = pulse.x * W;
    const screenY = pulse.y * H;
    const maxR = W * 0.35;

    for (let ring = 0; ring < 3; ring++) {
      const r = pulse.r - ring * 18;
      if (r < 0) continue;
      const a = pulse.life * (1 - r / maxR) * (0.15 - ring * 0.04);
      if (a <= 0) continue;
      ctx.beginPath();
      ctx.arc(screenX, screenY, r, 0, Math.PI * 2);
      ctx.strokeStyle = rgb(C.sunCol, a);
      ctx.lineWidth = lerp(2, 0.5, ring / 3);
      ctx.stroke();
    }
  });
}

function drawVignette(p) {
  const vg = ctx.createRadialGradient(W/2, H/2, W*0.1, W/2, H/2, W*0.85);
  const vigAlpha = lerp(0.7, 0.45, p);
  vg.addColorStop(0, 'transparent');
  vg.addColorStop(1, `rgba(0,0,0,${vigAlpha})`);
  ctx.fillStyle = vg;
  ctx.fillRect(0, 0, W, H);
}

// ─── CURSOR RING STYLING ──────────────────────────────────────────────────────
function updateCursorStyle() {
  const p = S.smoothPos;
  const h = Math.round(lerp(220, 40, p));
  ring.style.borderColor = `hsla(${h}, 60%, 70%, 0.4)`;
}

// ─── SCROLL DECAY ────────────────────────────────────────────────────────────
setInterval(() => {
  S.scroll = lerp(S.scroll, 0, 0.05);
}, 50);

// ─── TICK ────────────────────────────────────────────────────────────────────
function tick() {
  updateCursorStyle();
  requestAnimationFrame(tick);
}

draw();
tick();
</script>
</body>
</html>
